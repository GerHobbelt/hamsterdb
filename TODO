
I Am Legend:

Items are sorted by priority (highest on top).
o a pending  TODO item (for the current release)
. a pending  TODO item (for future releases)
x a finished TODO item

-----------------------------------------------------------------------------
This Branch Is About Integrating The hamsterdb2 Functionality!!!!!
-----------------------------------------------------------------------------
The big headline is:
As a user i want to run many Transactions in parallel with high performance.
I'm using multiple threads b/c my CPU has multiple cores, and expect hamsterdb
to scale with the number of cores.
==============================================================================

x clean up and refactor the code
    x os.h
    x os_posix.cc
    x os_win32.cc
    x packstart.h
    x packstop.h
    x rb.h
    x serial.h
    x version.h
    x util.cc
    x util.h
    x config.h
    x internal_fwd_decl.h
    x errorinducer.h
    x endianswap.h
    x mem.cc
    x mem.h
    x error.cc
        fill dbg_lock, dbg_unlock
    x error.h
        ham_assert/ham_verify: remove second parameter
    x cache.cc
    x cache.h
    x changeset.cc
    x changeset.h
    x device.cc
    x device.h
    x journal.cc
    x journal.h
    x journal_entries.h
    x log.cc
    x log.h
    x page.cc
    x page.h
    x extkeys.h
    x hash-table.h
    x blob.h
    x blob.cc
        x use os_writev when writing blob header/body - not possible
        x move duplicate stuff into btree_dupes.*, refactor
            replace __duplicate_get_table with BlobManager::read (needs to
                dynamically resize the buffer)

    x protocol - finally get rid of it
      x Protocol: default constructor should assign type

    x remote.cc
      x create Protocol objects on the stack whenever possible!
      x once more check for indention, spaces etc
    x hamserver.cc
      x create Protocol objects on the stack whenever possible!

    x include/ham/hamsterdb.h
    x include/ham/hamsterdb_int.h
    x include/ham/hamsterdb_stats.h

x remove the mutex code - for now we leave it as is
    x cache
    x extkey-cache
    x log
    x journal
    x changeset
    x device
    x freelist
    x backend

x implementation of hamsterdb should move into namespace ham; otherwise
    there are conflicts if users have a C++ class called Database or
    Environment etc

x see Laurent's email on the mailing list
    x 30 million keys (with Transactions)
    x group 2 million inserts into a single Transaction
    x then commit; the commit requires about 100 seconds
    -> do profiling on "master" and "v2"!

x rename HAM_IN_MEMORY_DB to HAM_IN_MEMORY

x continue with refacoring - indention, coding style, better design etc...
    x backend.h
    x hamsterdb_stats - make private, not public
        x rename to statistics.h
        x remove everything that's not required
    x hamsterdb_stats - make private, not public
        x rename to statistics.h
        x remove everything that's not required
    x btree_stats.h
        x remove everything that is not required
        x namespace Btree::Statistics
        x adjust coding style
        x fix get_global_perf_data, db_get_perf_data
    x btree_stats.cc
        x adjust coding style
        x move from db.h to btree.h
        x should use arena for lower/upper bounds and use
            HAM_KEY_USERALLOC when calling db->get_extended_key()
    x btree.h
        x remove namespace Btree
        x Statistics -> BtreeStatistics
        x rename btree_node_t -> BtreeNode (with getters/setters)
        x move BtreeNode to btree_node.h
        x remove global functions
        x do not use btree_cursor_t in backend.h, only use Cursor
    x btree.cc
        x code formatting
        x get rid of ham_bool_t
        x replace db_get_keysize() with backend->get_keysize()
    x btree_key.h
        x code formatting
        x rename btree_key_t -> BtreeKey (with getters/setters)
        x Backend::read_key -> move to BtreeBackend? no, leave it
        x all #defines -> enum
        x db_get_int_key_header_size -> Backend::get_full_keysize(payload_size)
    x btree_key.cc
        x code formatting
    x btree_check.cc
        x improve BtreeCheckAction; use it as template for enum, find, etc
        x constructor takes BtreeBackend
    x btree_enum.cc
        x remove scratchpad, use member variables
=======
>>>>>>> async flush is now disabled by default

o involve everyone in decisions on the new interface
  Do you use any of the HAM_HINT_* flags?
    If yes, would it be very problematic if I would remove this functionality?
  Do you use any of the HAM_DAM_* flags?
    If yes, would it be very problematic if I would remove this functionality?
  Do you use AES encryption?
    If yes, would it be very problematic if I would remove this functionality?
  Do you use zlib compression?
    If yes, would it be very problematic if I would remove this functionality?
  Do you use other file filters/record filters?
  Do you use any of the functions/structures in hamsterdb_stats.h?
  Do you use any of the functions/structures in hamsterdb_int.h?
    ham_get_keycount_per_page
    TODO @@@ - be more specific
  Do you use to insert duplicate keys at exact positions (i.e. use one of
        HAM_CURSOR_INSERT_BEFORE, HAM_CURSOR_INSERT_AFTER,
        HAM_CURSOR_INSERT_FIRST, HAM_CURSOR_INSERT_LAST)?
    If yes, would it be very problematic if I would remove this functionality?
  Do you use ham_cursor_move in combination with HAM_SKIP_DUPLICATES
        or HAM_ONLY_DUPLICATES?
    If yes, would it be very problematic if I would remove this functionality?
  Do you use sorted duplicates?
    If yes, would it be very problematic if I would remove this functionality?

o clean up interface
    o rename ham_env_open_ex to ham_env_open, remove ham_open[_ex]
    o rename ham_env_create_ex to ham_env_create, remove ham_create[_ex]
    o rename ham_cursor_find_ex to ham_cursor_find
    o clean up ham_flush, ham_env_flush
    o clean up ham_get_parameters, ham_env_get_parameters, ham_get_flags
    o clean up ham/hamsterdb_stats.h, ham/hamsterdb_int.h
        
o flush in background (asynchronously)
    x need new flag in header file HAM_DISABLE_ASYNCHRONOUS_FLUSH
    x if in-memory database: disable async flush
    x if transactions are disabled: disable async flush
    x if enabled: create background thread, wait for signal
    x ham_env_flush: if txn are enabled then try to flush them to disk

    x if disabled: use current code path
    x if enabled: trigger a signal
    x if signalled: lock env, flush transactions (same as ham_env_flush)
    x move the whole thread into a separate worker class
    x have a separate function to do the final flushes and exit the thread
        attn: env->m_mutex is locked!

    x check unittests; there are still race conditions, i guess when
        closing the Environment -> no, but when circumventing the exported
        ham_* functions (because there's no lock in place)
        x starting TempTxnCursorTest::cloneUncoupledBtreeCursorTest
        x starting TempTxnCursorTest::closeCoupledBtreeCursorTest

    x add tests
        x if in-memory database: disable async flush
        x if transactions are disabled: disable async flush

    x how to deal with an error in the background thread???
        x store in Environment, then return in every exported function
        x required in Java API
        x required in .NET API
        x add unittests (needs error inducer?)

    o default: async flush is OFF!
        x change documentation in header file
        x change the code
        o add a few tests (w/ ham_env_flush)

    o batch updates
        o wait for 10 committed transactions OR 2 seconds (configurable
            through parameters)
        o unlock env->mutex after EVERY committed transaction (or even after
            every single op?)
    x default: async flush is OFF!
        x change documentation in header file
        x change the code
        x add test (w/ ham_env_flush)
        x unlock env->mutex after EVERY committed transaction

    o extend monster tests
        x with async flush
        x without async flush
        o extend/run performance test
        o run monster tests

    o documentation
        o tutorial
        o faq

o continue with refacoring - indention, coding style, better design etc...
    o btree_find.cc
        o remove scratchpad, use member variables
        o BtreeFindAction is a friend of BtreeBackend
    o btree_check.cc
        o improve BtreeCheckAction; use it as template for enum, find, etc
        o constructor takes BtreeBackend
        o BtreeCheckAction is a friend of BtreeBackend
        o remove scratchpad, use member variables
        o replace db_get_keysize() with backend->get_keysize()
    o btree_enum.cc
        o remove scratchpad, use member variables
        o replace db_get_keysize() with backend->get_keysize()
    o btree_find.cc
        o remove scratchpad, use member variables
>>>>>>> async flush is now disabled by default
        o always use a cursor, and when doing approx matching then simply
            move left or right with that cursor
        o replace db_get_keysize() with backend->get_keysize()
    o btree_insert.cc
        o split when going down
        o replace db_get_keysize() with backend->get_keysize()
        o remove scratchpad, use member variables
    o btree_erase.cc
        o replace db_get_keysize() with backend->get_keysize()
        o remove scratchpad, use member variables

    o btree_cursor.cc
    o btree_cursor.h
        o use memory arena for uncoupling the key
        o replace db_get_keysize() with backend->get_keysize()

    ==> get rid of the whole freelist; no need to refactor the existing
        code
    o freelist.h
    o freelist.cc
    o freelist_statistics.h
        o split into env/db/freelist
        o remove unused code - also from public interface?
        o protect env and freelist with mutex
        o in db: assert that the db is locked
    o freelist_statistics.cc
        remove everything that is not required

    o cursor.cc
    o cursor.h
    o db.cc
        o should use arena for get_extended_key
        o completely hide the local/remote implementation in the database
        o move more members from Database to the Implementation classes
        o improve abstraction
    o db.h
    o env.cc
        o completely hide the local/remote implementation in the Environment
        o move more members from Environment to the Implementation classes
        o improve abstraction
    o env.h

    o txn.cc
        o convert to clean c++ code
        o avoid single code allocations; use an arena allocator based
            on a ByteArray
        use an arena allocator for everything that's stored in a transaction
        the arena should allocate pages with dynamic sizes; if a page is
        no longer used it will be stored in a lookaside list
    o txn_cursor.cc
    o txn_cursor.h
    o txn.h

    o hamsterdb.cc
    o configuration: move into separate file
    o blob manager
    o introduce a buffer manager?
        o i.e. holds the cache and manages the device
        o i.e. for de-coupling freelist from env
        o i.e. for de-coupling btree from db and env

    o unittests
        o code formatting
        o reduce bfc to a single header file, or use boost unittest framework
            http://www.boost.org/doc/libs/1_35_0/libs/test/doc/components/utf/index.html
            http://www.beroux.com/english/articles/boost_unit_testing/
            http://www.alittlemadness.com/2009/03/31/c-unit-testing-with-boosttest/

    o get rid of ham_bool_t, replace with bool whenever possible

o fix usage of DB_NEW_PAGE_DOES_THRASH_CACHE

o freelist: store the last successful freelist page in the hinter of the
    database

o is there a way to group all changeset flushes of a Transaction into one
    changeset? that way we would avoid the frequent syncs
    o would have to remove all of assert(changeset.is_empty())
    o but we can use that assert prior to txn_begin

o is the recovery working if there's a crash during ham_close?

o also remove locking from C# and Java APIs

o why do tests with 20 threads fail with oom when using mmap? the cache limits
    should still work

o clean up the "close" functions
    o ham_close - move all functionality to Database::close
    o ham_env_close - move all functionality to Environment::close
    o ~Database: call close(), then simplify all code
    o ~Environment: call close(), then simplify all code
    o Cursor::close: currently (nearly) empty; merge with ~Cursor and
        Database::close_cursor()
    o do not have st2/st; just fail if there's a serious problem

o python API - update and integrate
    o rewrite with boost::python??
    o also add to win32 package

o continue with c++-ification of db.h/db.cc

o c++-ify the backend
    o replace with C++ class and inheritance
    o BtreeBackend does not require to store in little/big-endian!
    o remove be_set_dirty, replace with be->_fun_flush()
    o btree has keydata1, keydata2 - why? better use DynamicArray?





o move flushing of transactions in background
    o new flag HAM_DISABLE_ASYNC_COMMITS
    o need new test: n threads; each thread inserts keys [i*n, i*(n+1))
    o make sure that each Database accesses its own pages; i.e. do not share
        blob pages between databases. Each database stores the address of the
        previously used blob page in order to reduce freelist access
    o when flushing and values are written to multiple databases: write them
        in parallel

o need a function to get the txn of a conflict (same as in v2)
    ham_status_t ham_txn_get_conflicting_txn(ham_txn_t *txn, ham_txn_t **other);
        oder: txn-id zurückgeben?
    o also add to c++ API
    o add documentation (header file)
    o add documentation (wiki)

o recovery: re-create pending transactions (if required)
    o needs a function to enumerate them

o c++-ify the transaction






o allow transactions in-memory

o allow transactions w/o journal

o allow transactions w/o recovery

o rename HAM_WRITE_THROUGH to HAM_ENABLE_FSYNC

o new node format:
    iiikkkkkkkkkrrrrrrrr

    iii: fixed size index (skip-list)
    kkk: keys
    rrr: records
    keys can have different compressions (bitmap, suppress null, ...)
    records are compressed; will be multiplied by BLOCKSIZE (32)
    each key consists of { char flag; short record_id; char data[1]; }
        where record_id is an offset into rrrrrrrrr
    keys are sorted lazily (i.e. inserted at the end and only sorted
        when flushed to disk or when searched

. android port (needs new java api) in /contrib directory (it's on a separate
    branch)

. new test case for cursors
    insert (1, a)
    insert (1, b) (duplicate of 1)
    move (last) (-> 1, b)
    insert (1, c)
    move (last) (-> 1, c)? is the dupecache updated correctly?

. look for someone who can write a PHP or Perl or Ruby wrapper

. implement support for partial keys

. test with tcmalloc; if it works then also use it in the master branch, but
    make sure that memory consumption does not increase significantly

. there are a couple of areas where a btree cursor is uncoupled, just to
    retrieve the key and to couple the txn-key. that's not efficient
        db.c:__btree_cursor_points_to
        db.c:__compare_cursors
        txn_cursor.c:cursor_sync
        txn_cursor.c:cursor_overwrite
    o move to a separate function
    o try to optimize

. hash-table.h: the foreach/remove_if/visitor pattern is clumsy. use
    functor or class w/ operator() instead
. changeset: use a generic hash table for fast lookup (but leave list in place
    for everything else)
. cache: use a generic hash table

. add tests to verify that the cursor is not modified if an operation fails!
    (in cursor.cpp:LongTxnCursorTest are some wrapper functions to move or
    insert the cursor; that's a good starting point)

. the whole c++ protocol should be c++-ified

. move the whole configuration (key sizes, parameters, page size, etc) into a
    separate class which is instantiated by the env

. c++-ify the btree node representation;
    o include duplicates as well! disentangle duplicates from blob-handling

. c++-ify the blob handling and split off the duplicates

. cleanup db.h/db.cc - move functions into Database or
    DatabaseImplementationLocal namespace - but take care b/c these functions
    are also used by Cursor or other modules which don't necessarily have
    access to the Local stuff
    o db_get_key_count
    o db_alloc_page
    o db_fetch_page
    o db_insert_txn
    o db_erase_txn
    o db_find_txn
    o db_check_insert_conflicts
    o db_check_erase_conflicts
    o __increment_dupe_index

. c++-ify everything else

. device, page and os shold no longer return errors but throw exceptions

XXXXXXXXXXXXXXXXXXXXX release 2.0.0 STABLE !!! XXXXXXXXXXXXXXXXXXXXXXXXXXXXX

. new flag for transactions: HAM_TXN_WILL_COMMIT
    if this flag is set, then write all records directly to the blob, not
    to the log. the log will only contain the rid.
    o document this (and also the drawback - that an abort will lose the
        blobs and they cannot be reused
    -> this affects all temporary ham_insert-transactions
    (not sure if this should get high priority)

o hamsterdb.com
    x add twitter feed
    o API documentation: don't link to "modules" but to startup page, update
        with newest version
    o crupp.de: do a backup of the database
    . google +1 button
    . can we use something like Aller.font?

o update documentation
    x in header file
    o in the wiki
        o don't forget to list all functions that are currently disabled
            w/ txn's -> sorting dupes, approx. matching, ...
        o transactional behavior/conflicts of duplicate keys
    o in the wiki: start with internal documentation
        o transactions
        o architecture
        o btree
        o journal/log
        o cache
        o I/O
        o unittests
        o cursor(s)
        o monstertests - how to use them?

o fully (!) automize the whole release process for unix; the result (on
    success) are the following files:
    o tar-ball
    o the README
    o the documentation as a tar
    o the Changelog
    o the release notes (a template)
    o the output (xml) of the monster tests

. port to WinCE

o how can we extend the monster-tests to have reliable tests for transactions?

. if memory consumption in the txn-tree is too high: flush records to disk
    (not sure if this should get high priority)

o when recovering, give users the choice if active transactions should be
    aborted (default behavior) or re-created

o extkeys: don't use txn_id for the 'age', use lsn instead

o the DatabaseImplementation subclass is not neccessary; all subclasses
    can directly derive from Database.

. allow use of transactions without a log/journal

. allow use of transactions for in-memory databases

XXXXXXXXXXXXXXXXXXXXX release 2.0.0 STABLE XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

o ham_get_count: could be atomically updated with every journal entry

o when flushing a changeset: sort by offset, use writev()

o add concurrency (on a high level)

o flush transactions in background

. have a flag to disable flushing of logfiles/journal files (or flush them
    async.)

o continue as described in integrate-ham2.txt...

